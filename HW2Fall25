
Robert Barrett 

// Include files
#include <sys/time.h>
#include <stdio.h>

// Defines
#define N 1500 // Length of the vector

// Global variables
float *A_CPU, *B_CPU, *C_CPU; 
float *A_GPU, *B_GPU, *C_GPU; 
dim3 BlockSize; 
dim3 GridSize; 
float Tolerance = 0.01;


void setUpDevices();
void allocateMemory();
void innitialize();
void addVectorsCPU(float*, float*, float*, int);
__global__ void addVectorsGPU(float, float, float, int);
bool  check(float*, int);
long elaspedTime(struct timeval, struct timeval);
void cleanUp();


void setUpDevices()
{
	BlockSize.x = 512; // I tried setting the block size x to 1024, but 512 seemed to run slightly faster in this context. 
	BlockSize.y = 1;
	BlockSize.z = 1;
	
	GridSize.x = 1;
	GridSize.y = 1;
	GridSize.z = 1;
}


void allocateMemory()
{	
					
	A_CPU = (float*)malloc(N*sizeof(float));
	B_CPU = (float*)malloc(N*sizeof(float)); // the amount of memory we need is the length of the vector times the size of a float.
	C_CPU = (float*)malloc(N*sizeof(float));
	
	
	cudaMalloc(&A_GPU,N*sizeof(float));
	cudaMalloc(&B_GPU,N*sizeof(float));  // using cudaMalloc to allocate memory on the GPU.
	cudaMalloc(&C_GPU,N*sizeof(float));

}


void innitialize()
{
	for(int i = 0; i < N; i++)
	{		
		A_CPU[i] = (float)i;	
		B_CPU[i] = (float)(2*i); // Initializing the vectors with some known values to compare to. each element in A is i and each element in B is 2*i., so the sum of those elements is 3i
		// and the formula for the sum of each element of the resultant vector is 3*(n-1)*n/2 where n is the length of the vector. This become relevant in the check function, as this
		// is what will be compared to. 
	}
}


void addVectorsCPU(float *a, float *b, float *c, int n)
{
	for(int id = 0; id < n; id++)
	{ 
		c[id] = a[id] + b[id];
	}
}


__global__ void addVectorsGPU(float *a, float *b, float *c, int n) 
{
	int id = threadIdx.x; // Each thread gets its own ID number.
	int stride = blockDim.x; // stride 'jumps' by the total number of threads in the block.
	while(id < n) // Making sure we do not go out of bounds of our vectors.
	{
		c[id] = a[id] + b[id]; // this while loops makes sure each element of the vector gets added. 
		id += stride;
	}
}

// Checking to see if anything went wrong in the vector addition.
bool check(float *c, int n, float tolerence)
{
	int id;
	double myAnswer;
	double trueAnswer;
	double percentError;
	double m = n-1; // Needed the -1 because we start at 0.
	
	myAnswer = 0.0;
	for(id = 0; id < n; id++)
	{ 
		myAnswer += c[id];
	}
	// this represents the true answer of adding the two vectors together.
	trueAnswer = 3.0*(m*(m+1))/2.0;
	// using fabs for absolute value of a float instead of abs which is for integers.
	percentError = fabs((myAnswer - trueAnswer)/trueAnswer)*100.0;
	
	if(percentError < Tolerance) 
	{
		return(true);
	}
	else 
	{
		return(false);
	}
}

// Calculating elasped time.
long elaspedTime(struct timeval start, struct timeval end)
{
	// tv_sec equals the number of seconds past the Unix epoch 01/01/1970
	// tv_usec equals the number of microseconds past the current second.
	
	long startTime = start.tv_sec * 1000000 + start.tv_usec; // In microseconds.
	long endTime = end.tv_sec * 1000000 + end.tv_usec; // In microseconds

	// Returning the total time elasped in microseconds
	return endTime - startTime;
}

// Cleaning up memory after we are finished.
void CleanUp()
{
	// Freeing host "CPU" memory.
	free(A_CPU); 
	free(B_CPU); 
	free(C_CPU);
	
	cudaFree(A_GPU); 
	cudaFree(B_GPU); 
	cudaFree(C_GPU);
}

int main()
{
	timeval start, end;
	long timeCPU, timeGPU;
	
	// Setting up the GPU
	setUpDevices();
	
	// Allocating the memory you will need.
	allocateMemory();
	
	// Putting values in the vectors.
	innitialize();
	
	// Adding on the CPU
	gettimeofday(&start, NULL);
	addVectorsCPU(A_CPU, B_CPU ,C_CPU, N);
	gettimeofday(&end, NULL);
	timeCPU = elaspedTime(start, end);
	
	// Zeroing out the C_CPU vector just to be safe because right now it has the correct answer in it.
	for(int id = 0; id < N; id++)
	{ 
		C_CPU[id] = 0.0;
	}
	
	// Adding on the GPU
	gettimeofday(&start, NULL);
	
	// Copy Memory from CPU to GPU		
	cudaMemcpyAsync(A_GPU, A_CPU, N*sizeof(float), cudaMemcpyHostToDevice); // CPU = Host, GPU = Device
	cudaMemcpyAsync(B_GPU, B_CPU, N*sizeof(float), cudaMemcpyHostToDevice);
	
	addVectorsGPU<<<GridSize,BlockSize>>>(A_GPU, B_GPU ,C_GPU, N); // this is the cuda function call.
	
	// Copy Memory from GPU to CPU	
	cudaMemcpyAsync(C_CPU, C_GPU, N*sizeof(float), cudaMemcpyDeviceToHost); // bringing the result back to the CPU.
	
	// Making sure the GPU and CPU wait until each other are at the same place.
	cudaDeviceSynchronize(); //syncing the CPU (Host) and the GPU (Device). 
	
	gettimeofday(&end, NULL);
	timeGPU = elaspedTime(start, end);
	
	// Checking to see if all went correctly.
	if(check(C_CPU, N, Tolerance) == false)
	{
		printf("\n\n Something went wrong in the GPU vector addition\n");
	}
	else
	{
		printf("\n\n You added the two vectors correctly on the GPU");
		printf("\n The time it took on the CPU was %ld microseconds", timeCPU);
		printf("\n The time it took on the GPU was %ld microseconds", timeGPU);
	}
	
	// Your done so cleanup your room.	
	CleanUp();	
	
	// Making sure it flushes out anything in the print buffer.
	printf("\n\n");
	
	return(0);
}
